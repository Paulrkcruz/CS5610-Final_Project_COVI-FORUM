{"ast":null,"code":"import assertString from './util/assertString';\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\n\nvar ipv4Maybe = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;\nvar ipv6Block = /^[0-9A-F]{1,4}$/i;\nexport default function isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  assertString(str);\n  version = String(version);\n\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  } else if (version === '4') {\n    if (!ipv4Maybe.test(str)) {\n      return false;\n    }\n\n    var parts = str.split('.').sort(function (a, b) {\n      return a - b;\n    });\n    return parts[3] <= 255;\n  } else if (version === '6') {\n    var addressAndZone = [str]; // ipv6 addresses could have scoped architecture\n    // according to https://tools.ietf.org/html/rfc4007#section-11\n\n    if (str.includes('%')) {\n      addressAndZone = str.split('%');\n\n      if (addressAndZone.length !== 2) {\n        // it must be just two parts\n        return false;\n      }\n\n      if (!addressAndZone[0].includes(':')) {\n        // the first part must be the address\n        return false;\n      }\n\n      if (addressAndZone[1] === '') {\n        // the second part must not be empty\n        return false;\n      }\n    }\n\n    var blocks = addressAndZone[0].split(':');\n    var foundOmissionBlock = false; // marker to indicate ::\n    // At least some OS accept the last 32 bits of an IPv6 address\n    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says\n    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,\n    // and '::a.b.c.d' is deprecated, but also valid.\n\n    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);\n    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;\n\n    if (blocks.length > expectedNumberOfBlocks) {\n      return false;\n    } // initial or final ::\n\n\n    if (str === '::') {\n      return true;\n    } else if (str.substr(0, 2) === '::') {\n      blocks.shift();\n      blocks.shift();\n      foundOmissionBlock = true;\n    } else if (str.substr(str.length - 2) === '::') {\n      blocks.pop();\n      blocks.pop();\n      foundOmissionBlock = true;\n    }\n\n    for (var i = 0; i < blocks.length; ++i) {\n      // test for a :: which can not be at the string start/end\n      // since those cases have been handled above\n      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {\n        if (foundOmissionBlock) {\n          return false; // multiple :: in address\n        }\n\n        foundOmissionBlock = true;\n      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {// it has been checked before that the last\n        // block is a valid IPv4 address\n      } else if (!ipv6Block.test(blocks[i])) {\n        return false;\n      }\n    }\n\n    if (foundOmissionBlock) {\n      return blocks.length >= 1;\n    }\n\n    return blocks.length === expectedNumberOfBlocks;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/kurtiscruz/Desktop/GitHub/CS5610-Final_Project_COVI-FORUM/node_modules/validator/es/lib/isIP.js"],"names":["assertString","ipv4Maybe","ipv6Block","isIP","str","version","arguments","length","undefined","String","test","parts","split","sort","a","b","addressAndZone","includes","blocks","foundOmissionBlock","foundIPv4TransitionBlock","expectedNumberOfBlocks","substr","shift","pop","i"],"mappings":"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","sourcesContent":["import assertString from './util/assertString';\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\n\nvar ipv4Maybe = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;\nvar ipv6Block = /^[0-9A-F]{1,4}$/i;\nexport default function isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  assertString(str);\n  version = String(version);\n\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  } else if (version === '4') {\n    if (!ipv4Maybe.test(str)) {\n      return false;\n    }\n\n    var parts = str.split('.').sort(function (a, b) {\n      return a - b;\n    });\n    return parts[3] <= 255;\n  } else if (version === '6') {\n    var addressAndZone = [str]; // ipv6 addresses could have scoped architecture\n    // according to https://tools.ietf.org/html/rfc4007#section-11\n\n    if (str.includes('%')) {\n      addressAndZone = str.split('%');\n\n      if (addressAndZone.length !== 2) {\n        // it must be just two parts\n        return false;\n      }\n\n      if (!addressAndZone[0].includes(':')) {\n        // the first part must be the address\n        return false;\n      }\n\n      if (addressAndZone[1] === '') {\n        // the second part must not be empty\n        return false;\n      }\n    }\n\n    var blocks = addressAndZone[0].split(':');\n    var foundOmissionBlock = false; // marker to indicate ::\n    // At least some OS accept the last 32 bits of an IPv6 address\n    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says\n    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,\n    // and '::a.b.c.d' is deprecated, but also valid.\n\n    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);\n    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;\n\n    if (blocks.length > expectedNumberOfBlocks) {\n      return false;\n    } // initial or final ::\n\n\n    if (str === '::') {\n      return true;\n    } else if (str.substr(0, 2) === '::') {\n      blocks.shift();\n      blocks.shift();\n      foundOmissionBlock = true;\n    } else if (str.substr(str.length - 2) === '::') {\n      blocks.pop();\n      blocks.pop();\n      foundOmissionBlock = true;\n    }\n\n    for (var i = 0; i < blocks.length; ++i) {\n      // test for a :: which can not be at the string start/end\n      // since those cases have been handled above\n      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {\n        if (foundOmissionBlock) {\n          return false; // multiple :: in address\n        }\n\n        foundOmissionBlock = true;\n      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {// it has been checked before that the last\n        // block is a valid IPv4 address\n      } else if (!ipv6Block.test(blocks[i])) {\n        return false;\n      }\n    }\n\n    if (foundOmissionBlock) {\n      return blocks.length >= 1;\n    }\n\n    return blocks.length === expectedNumberOfBlocks;\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"module"}