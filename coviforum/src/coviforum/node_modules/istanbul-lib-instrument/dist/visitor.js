"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crypto = require("crypto");

var _core = require("@babel/core");

var _schema = require("@istanbuljs/schema");

var _sourceCoverage = require("./source-coverage");

var _constants = require("./constants");

// pattern for istanbul to ignore a section
const COMMENT_RE = /^\s*istanbul\s+ignore\s+(if|else|next)(?=\W|$)/; // pattern for istanbul to ignore the whole file

const COMMENT_FILE_RE = /^\s*istanbul\s+ignore\s+(file)(?=\W|$)/; // source map URL pattern

const SOURCE_MAP_RE = /[#@]\s*sourceMappingURL=(.*)\s*$/m; // generate a variable name from hashing the supplied file path

function genVar(filename) {
  const hash = (0, _crypto.createHash)(_constants.SHA);
  hash.update(filename);
  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);
} // VisitState holds the state of the visitor, provides helper functions
// and is the `this` for the individual coverage visitors.


class VisitState {
  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {
    this.varName = genVar(sourceFilePath);
    this.attrs = {};
    this.nextIgnore = null;
    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);

    if (typeof inputSourceMap !== 'undefined') {
      this.cov.inputSourceMap(inputSourceMap);
    }

    this.ignoreClassMethods = ignoreClassMethods;
    this.types = types;
    this.sourceMappingURL = null;
  } // should we ignore the node? Yes, if specifically ignoring
  // or if the node is generated.


  shouldIgnore(path) {
    return this.nextIgnore || !path.node.loc;
  } // extract the ignore comment hint (next|if|else) or null


  hintFor(node) {
    let hint = null;

    if (node.leadingComments) {
      node.leadingComments.forEach(c => {
        const v = (c.value ||
        /* istanbul ignore next: paranoid check */
        '').trim();
        const groups = v.match(COMMENT_RE);

        if (groups) {
          hint = groups[1];
        }
      });
    }

    return hint;
  } // extract a source map URL from comments and keep track of it


  maybeAssignSourceMapURL(node) {
    const extractURL = comments => {
      if (!comments) {
        return;
      }

      comments.forEach(c => {
        const v = (c.value ||
        /* istanbul ignore next: paranoid check */
        '').trim();
        const groups = v.match(SOURCE_MAP_RE);

        if (groups) {
          this.sourceMappingURL = groups[1];
        }
      });
    };

    extractURL(node.leadingComments);
    extractURL(node.trailingComments);
  } // for these expressions the statement counter needs to be hoisted, so
  // function name inference can be preserved


  counterNeedsHoisting(path) {
    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();
  } // all the generic stuff that needs to be done on enter for every node


  onEnter(path) {
    const n = path.node;
    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do

    if (this.nextIgnore !== null) {
      return;
    } // check hint to see if ignore should be turned on


    const hint = this.hintFor(n);

    if (hint === 'next') {
      this.nextIgnore = n;
      return;
    } // else check custom node attribute set by a prior visitor


    if (this.getAttr(path.node, 'skip-all') !== null) {
      this.nextIgnore = n;
    } // else check for ignored class methods


    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {
      this.nextIgnore = n;
      return;
    }

    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {
      this.nextIgnore = n;
      return;
    }
  } // all the generic stuff on exit of a node,
  // including reseting ignores and custom node attrs


  onExit(path) {
    // restore ignore status, if needed
    if (path.node === this.nextIgnore) {
      this.nextIgnore = null;
    } // nuke all attributes for the node


    delete path.node.__cov__;
  } // set a node attribute for the supplied node


  setAttr(node, name, value) {
    node.__cov__ = node.__cov__ || {};
    node.__cov__[name] = value;
  } // retrieve a node attribute for the supplied node or null


  getAttr(node, name) {
    const c = node.__cov__;

    if (!c) {
      return null;
    }

    return c[name];
  } //


  increase(type, id, index) {
    const 